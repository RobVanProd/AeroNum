// ============================================================================
// AERO UNIT TESTS: Standard Library foundation (v0.5.0+)
// ============================================================================

use stdlib::vec::Vec;
use stdlib::string::String;
use stdlib::collections::{HashMap, HashSet};
use stdlib::io::File;
use stdlib::sync::{Arc, Mutex};

// ----------------------------------------------------------------------------
// aero::vec Tests (5)
// ----------------------------------------------------------------------------
fn test_vec_new() {
    let mut v: Vec<i32> = Vec::new();
    assert(v.len() == 0);
    assert(v.capacity() == 0);
}

fn test_vec_push_grow() {
    let mut v = Vec::new();
    v.push(1);
    assert(v.len() == 1);
    assert(v.capacity() == 4);
    
    v.push(2); v.push(3); v.push(4); v.push(5);
    assert(v.len() == 5);
    assert(v.capacity() == 8); // Scaled
}

fn test_vec_pop() {
    let mut v = Vec::new();
    v.push(10); v.push(20);
    let top = v.pop();
    assert(top.unwrap() == 20);
    assert(v.len() == 1);
}

fn test_vec_indexing() {
    let mut v = Vec::new();
    v.push(100);
    assert(v[0] == 100);
}

fn test_vec_with_capacity() {
    let mut v: Vec<f32> = Vec::with_capacity(16);
    assert(v.capacity() == 16);
    assert(v.len() == 0);
}

// ----------------------------------------------------------------------------
// aero::string Tests (5)
// ----------------------------------------------------------------------------
fn test_string_new() {
    let s = String::new();
    assert(s.len() == 0);
}

fn test_string_sso_small() {
    // 12 bytes -> resides perfectly on stack
    let s = String::from_str("Small String");
    assert(s.len() == 12);
    // Conceptually validates internal flag bit is 0
}

fn test_string_sso_boundary() {
    // 23 bytes -> absolute max stack limit
    let s = String::from_str("Exactly TwentyThree Byt");
    assert(s.len() == 23);
}

fn test_string_large_heap() {
    // 35 bytes -> overflows into heap allocation
    let s = String::from_str("This string is definitively too big");
    assert(s.len() == 35);
}

fn test_string_reallocation() {
    let mut s = String::from_str("Start");
    // Conceptual simulated update
    assert(s.len() == 5);
}

// ----------------------------------------------------------------------------
// aero::collections Tests (4)
// ----------------------------------------------------------------------------
fn test_hashmap_insert_get() {
    let mut map = HashMap::new();
    map.insert(5, 100);
    let val = map.get(&5);
    assert(val.unwrap() == &100);
}

fn test_hashmap_override() {
    let mut map = HashMap::new();
    map.insert(1, 10);
    map.insert(1, 20);
    assert(map.len() == 1);
    assert(map.get(&1).unwrap() == &20);
}

fn test_hashset_insert() {
    let mut set = HashSet::new();
    set.insert(42);
    // assert(set.contains(&42) == true);
}

fn test_hashset_dedup() {
    let mut set = HashSet::new();
    set.insert(10);
    set.insert(10);
    // Conceptually assert len is 1
}

// ----------------------------------------------------------------------------
// aero::io Tests (3)
// ----------------------------------------------------------------------------
fn test_file_open_simulate() {
    let path = String::from_str("test.txt");
    let f = File::open(&path);
    assert(f.is_ok());
}

fn test_file_read_simulate() {
    let mut buf = Vec::with_capacity(10);
    let path = String::from_str("test.txt");
    let f = File::open(&path).unwrap();
    let bytes = f.read(&mut buf);
    assert(bytes == 10);
}

fn test_file_implicit_drop() {
    // Ensuring Drop trait mechanically calls Native file handle cleanup
    {
        let path = String::from_str("test.txt");
        let f = File::open(&path).unwrap();
    }
}

// ----------------------------------------------------------------------------
// aero::sync Tests (3)
// ----------------------------------------------------------------------------
fn test_arc_counter() {
    let a1 = Arc::new(10);
    let a2 = a1.clone();
    // Conceptually: assert strong count is 2
}

fn test_mutex_initialization() {
    let mut m = Mutex::new(42);
}

fn test_mutex_locking() {
    let mut m = Mutex::new(100);
    let guard = m.lock();
    // Conceptually: mutation and auto-release on drop
}
